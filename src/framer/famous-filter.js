// @ts-nocheck
/* eslint-disable */
/* This file was generated by Unframer for Framer project 3e9f5e2dfe1fa837 "Unframer CMS Test", do not edit manually */
"use client";
import {
  Border,
  DELIMITER,
  FAVOURITES_FILTER_ID,
  FilterFieldType,
  FilterTextCondition,
  SearchBar,
  Superfields,
  borderPropertyControl,
  className,
  createBackground,
  css,
  fillProp,
  fillPropOnOff,
  fonts,
  getCollectionData,
  getSelectItemForField,
  stdin_default,
  stdin_default2,
  superfieldsId
} from "./chunks/chunk-5ATQGTHL.js";

// virtual:famous-filter
import { Fragment as Fragment3 } from "react";
import { ContextProviders } from "unframer";

// /:https://framerusercontent.com/modules/zih4XvD9VgCbMfkxqsdD/W8EvxVLii4iAJgYjBoCK/uSJVhQSyB.js
import { jsx as _jsx3, jsxs as _jsxs2, Fragment as _Fragment } from "react/jsx-runtime";
import { addFonts as addFonts2, ChildrenCanSuspend, ComponentViewportProvider, cx as cx2, getFonts, getFontsFromSharedStyle, PathVariablesContext, RichText, useComponentViewport as useComponentViewport2, useDynamicRefs, useLoadMorePaginatedQuery, useLocaleInfo as useLocaleInfo2, useQueryData as useQueryData2, useVariantState as useVariantState2, withCSS as withCSS3, withInfiniteScroll } from "unframer";
import { LayoutGroup as LayoutGroup2, motion as motion3, MotionConfigContext as MotionConfigContext2 } from "unframer";
import * as React2 from "react";

// /:https://framerusercontent.com/modules/LYyAFjx6EnDQcWGl8jCk/0oZlaeY8XOePOHwkQPcm/Filter.js
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import {
  addPropertyControls,
  ControlType,
  RenderTarget,
  useQueryData,
  withCSS
} from "unframer";
import { motion } from "unframer";
var FilterBy;
(function(FilterBy2) {
  FilterBy2["Field"] = "field";
  FilterBy2["Favourites"] = "favourites";
})(FilterBy || (FilterBy = {}));
var FilterType;
(function(FilterType2) {
  FilterType2["Dropdown"] = "dropdown";
  FilterType2["ButtonGroup"] = "buttonGroup";
  FilterType2["ToggleSwitch"] = "toggleSwitch";
  FilterType2["Checkbox"] = "checkbox";
})(FilterType || (FilterType = {}));
var OptionMode;
(function(OptionMode2) {
  OptionMode2["Auto"] = "auto";
  OptionMode2["Manual"] = "manual";
})(OptionMode || (OptionMode = {}));
var OptionOrder;
(function(OptionOrder2) {
  OptionOrder2["Default"] = "default";
  OptionOrder2["Alphabetical"] = "alphabetical";
})(OptionOrder || (OptionOrder = {}));
var ALL_SELECTED_VALUE = "[{(ALL)}]";
var LAYOUT_ALIGNMENTS = { fill: "center", left: "start", center: "center", right: "end" };
var TOGGLE_VALUES = { all: null, [ALL_SELECTED_VALUE]: null, off: false, on: true };
var DASHES_ONLY_REGEX = /^-+$/;
var CONDITION_FIELD_TYPES = [FilterFieldType.Text, FilterFieldType.Option, FilterFieldType.MultipleOptions];
var DIVIDER = "divider";
var FAVOURITES_URL_PARAMETER = "favorites";
var TRUE_VALUES = ["true", "yes", "on"];
var FALSE_VALUES = ["false", "no", "off"];
function FilterComponent(props) {
  var _props_collectionList, _filters_instanceId;
  const { superfieldsId: superfieldsId2, filterBy, options, referenceFieldName, referenceFieldType, buttonGroupLayout, buttonGroupStyle, toggleMultiOptions, toggleTwoStateOptions, toggleTwoStateText, dropdownStyle, toggleSwitchStyle, checkboxStyle, layout, transition } = props;
  const isCanvas = RenderTarget.current() === RenderTarget.canvas;
  const rawFieldType = filterBy == "field" ? props.fieldType : FilterFieldType.Toggle;
  const fieldName = filterBy === "field" ? rawFieldType == FilterFieldType.MultipleOptions ? props.optionFieldNames.join(DELIMITER) : props.fieldName : FAVOURITES_FILTER_ID;
  const isReference = isReferenceType(rawFieldType);
  const fieldType2 = rawFieldType === FilterFieldType.MultipleOptions ? FilterFieldType.Option : isReference ? referenceFieldType : rawFieldType;
  const filterType2 = filterBy === "field" ? fieldType2 === FilterFieldType.Toggle ? props.filterTypeToggle : props.filterTypeOption : props.filterTypeToggle;
  const allOption = fieldType2 === FilterFieldType.Toggle ? toggleMultiOptions.allOption : options.allOption;
  const showDividers = (fieldType2 === FilterFieldType.Option || fieldType2 === FilterFieldType.Text) && options.optionMode === "manual";
  const instanceId = filterBy === "favourites" ? FAVOURITES_FILTER_ID : isReference ? `${fieldName}${DELIMITER}${referenceFieldName}` : fieldName;
  const urlParameter = props.urlParameter ? props.urlParameter.name || (filterBy === "field" ? rawFieldType == FilterFieldType.MultipleOptions ? props.optionFieldNames.join(",") : fieldName : FAVOURITES_URL_PARAMETER) : null;
  const collectionList = (_props_collectionList = props.collectionList) === null || _props_collectionList === void 0 ? void 0 : _props_collectionList[0];
  const { query, propertyControlsById, propertyControlsByTitle, collections, multiReferenceIdMap, multiReferenceQueries } = getCollectionData(collectionList);
  const mainCollection = collections[0];
  const mainAlias = mainCollection === null || mainCollection === void 0 ? void 0 : mainCollection.alias;
  const mainPropertyControlsById = propertyControlsById[mainAlias] || {};
  const mainPropertyControlsByTitle = propertyControlsByTitle[mainAlias] || {};
  const select = [{ collection: mainAlias, name: "id", type: "Identifier" }];
  let multiReferenceSelect = null;
  let rAlias = null;
  if (!isCanvas && rawFieldType !== FilterFieldType.MultipleOptions) {
    if (isReference) {
      const selectItem = getSelectItemForField(fieldName, referenceFieldName, query, propertyControlsByTitle, collections);
      if (selectItem) {
        select.push(selectItem);
        rAlias = selectItem.collection;
      }
    } else {
      const selectItem = getSelectItemForField(fieldName, null, query, propertyControlsByTitle, collections);
      if (selectItem) {
        select.push(selectItem);
      }
    }
  }
  const collectionData = query ? useQueryData({ ...query, select }) : [];
  let rCollectionData = [];
  if (Array.isArray(multiReferenceSelect)) {
    const selectValue = multiReferenceSelect.find((v) => v && v.hasOwnProperty("collection"));
    if (selectValue) {
      const rQuery = multiReferenceQueries[selectValue.collection];
      if (rQuery) {
        rCollectionData = useQueryData({ ...rQuery, select: multiReferenceSelect, where: void 0, orderBy: void 0 });
      }
    }
  }
  let optionValues = [];
  if (fieldType2 === FilterFieldType.Option || fieldType2 === FilterFieldType.Text) {
    if (options.optionMode === "auto") {
      var _Object_keys;
      if ((_Object_keys = Object.keys(mainPropertyControlsById)) === null || _Object_keys === void 0 ? void 0 : _Object_keys.length) {
        if (rawFieldType === FilterFieldType.MultipleOptions) {
          const { optionFieldNames } = props;
          const optionValuesList = [];
          for (const fieldId in mainPropertyControlsById) {
            const control = mainPropertyControlsById[fieldId];
            if (optionFieldNames.includes(control.title)) {
              if (control.type === "enum") {
                optionValuesList.push(control.optionTitles);
              } else if (control.type === "string") {
                const allValues = /* @__PURE__ */ new Set();
                for (const index in collectionData) {
                  if (!isNaN(index)) {
                    const value2 = collectionData[index][fieldId];
                    if (value2 != "" && value2 != null) {
                      allValues.add(value2);
                    }
                  }
                }
                optionValuesList.push(Array.from(allValues));
              }
            }
          }
          optionValues = Array.from(new Set(optionValuesList.flat()));
          if (props.multipleOptionsNoneOption.length && optionValues.includes(props.multipleOptionsNoneOption)) {
            optionValues.splice(optionValues.indexOf(props.multipleOptionsNoneOption), 1);
          }
        } else {
          let control = null;
          let fieldId = null;
          if (isReference) {
            const rPropertyControlsByTitle = propertyControlsByTitle[rAlias];
            if (rPropertyControlsByTitle) {
              control = rPropertyControlsByTitle[referenceFieldName];
            }
            fieldId = control ? rawFieldType === FilterFieldType.Reference ? `${rAlias}.${control.id}` : control.id : null;
          } else {
            control = mainPropertyControlsByTitle[fieldName];
            fieldId = control ? control.id : null;
          }
          if (control) {
            if (control.type === "enum") {
              optionValues = control.optionTitles;
            } else if (control.type === "string") {
              const data = rawFieldType === FilterFieldType.MultiReference ? rCollectionData : collectionData;
              const allValues = /* @__PURE__ */ new Set();
              for (const index in data) {
                if (!isNaN(index)) {
                  const value2 = data[index][fieldId];
                  if (value2 !== "" && value2 !== null && value2 !== void 0) {
                    allValues.add(value2);
                  }
                }
              }
              optionValues = Array.from(allValues);
            }
          }
        }
      } else if (isCanvas && (filterType2 !== "dropdown" || !allOption)) {
        optionValues = [options.placeholder];
      }
      if (options.optionOrder === "alphabetical") {
        optionValues = optionValues.sort();
      }
    } else if (options.optionMode === "manual") {
      optionValues = options.optionValues;
    }
  }
  if (!Array.isArray(optionValues)) {
    optionValues = [];
  }
  const defaultOptionIsValid = options.defaultValue.length && optionValues.includes(options.defaultValue);
  let offValue = null;
  let onValue = null;
  let defaultValue = null;
  if (fieldType2 == FilterFieldType.Toggle) {
    if (filterType2 == "dropdown" || filterType2 == "buttonGroup") {
      const values = [];
      if (toggleMultiOptions.allOption) {
        values.push(null);
      }
      if (toggleMultiOptions.order == "yesNo") {
        if (toggleMultiOptions.yesOption) {
          values.push(true);
        }
        if (toggleMultiOptions.noOption) {
          values.push(false);
        }
      } else {
        if (toggleMultiOptions.noOption) {
          values.push(false);
        }
        if (toggleMultiOptions.yesOption) {
          values.push(true);
        }
      }
      defaultValue = values.includes(TOGGLE_VALUES[toggleMultiOptions.defaultValue]) ? TOGGLE_VALUES[toggleMultiOptions.defaultValue] : values[0];
    } else {
      offValue = TOGGLE_VALUES[toggleTwoStateOptions.offState];
      onValue = TOGGLE_VALUES[toggleTwoStateOptions.onState];
      defaultValue = toggleTwoStateOptions.defaultValue == "off" ? offValue : onValue;
    }
  } else {
    var _optionValues_;
    defaultValue = defaultOptionIsValid ? options.defaultValue : !options.allOption && filterType2 == "dropdown" ? (_optionValues_ = optionValues[0]) !== null && _optionValues_ !== void 0 ? _optionValues_ : null : null;
  }
  const [filters, setFilterValue] = stdin_default(superfieldsId2, (state) => [state.filters, state.setFilterValue], (state) => {
    let initialValue = defaultValue;
    if (urlParameter && !isCanvas) {
      const urlParams = new URLSearchParams(window.location.search);
      const paramValue = urlParams.get(urlParameter);
      if (paramValue) {
        if (fieldType2 === FilterFieldType.Toggle) {
          const lowerParamValue = paramValue.toLowerCase();
          if (TRUE_VALUES.includes(lowerParamValue)) {
            initialValue = true;
          } else if (FALSE_VALUES.includes(lowerParamValue)) {
            initialValue = false;
          }
        } else {
          if (paramValue.includes(DELIMITER)) {
            const values = paramValue.split(DELIMITER);
            if (values.every((value2) => optionValues.includes(value2))) {
              initialValue = paramValue;
            }
          } else if (optionValues.includes(paramValue)) {
            initialValue = paramValue;
          }
        }
      }
    }
    state.filters[instanceId] = { fieldName, referenceFieldName: isReference ? referenceFieldName : null, referenceFieldType: isReference ? referenceFieldType : null, value: initialValue, defaultValue, multiSelect: filterType2 == "buttonGroup" && props.multiSelect, fieldType: rawFieldType, noneOption: rawFieldType == FilterFieldType.MultipleOptions ? props.multipleOptionsNoneOption : void 0, condition: CONDITION_FIELD_TYPES.includes(fieldType2) ? props.textCondition : FilterTextCondition.Equals, urlParameter };
  });
  const value = isCanvas ? defaultValue : (_filters_instanceId = filters[instanceId]) === null || _filters_instanceId === void 0 ? void 0 : _filters_instanceId.value;
  const setFilter = (newValue) => {
    setFilterValue(instanceId, newValue);
  };
  const optionItems = [];
  if (fieldType2 === FilterFieldType.Option || fieldType2 === FilterFieldType.Text) {
    for (let i = 0; i < optionValues.length; i++) {
      const value2 = optionValues[i];
      if (showDividers && isDivider(value2)) {
        optionItems.push(DIVIDER);
      } else if (value2) {
        optionItems.push({ value: value2, text: value2 });
      }
    }
  } else if (fieldType2 == FilterFieldType.Toggle) {
    if (toggleMultiOptions.order == "yesNo") {
      if (toggleMultiOptions.yesOption) {
        optionItems.push({ value: "on", text: toggleMultiOptions.yesText });
      }
      if (toggleMultiOptions.noOption) {
        optionItems.push({ value: "off", text: toggleMultiOptions.noText });
      }
    } else {
      if (toggleMultiOptions.noOption) {
        optionItems.push({ value: "off", text: toggleMultiOptions.noText });
      }
      if (toggleMultiOptions.yesOption) {
        optionItems.push({ value: "on", text: toggleMultiOptions.yesText });
      }
    }
  }
  const layers = [];
  switch (filterType2) {
    case "dropdown":
      const dropdownArrow = dropdownStyle.arrow;
      const pt = dropdownStyle.paddingIsMixed ? dropdownStyle.paddingTop : dropdownStyle.padding;
      const pl = dropdownStyle.paddingIsMixed ? dropdownStyle.paddingLeft : dropdownStyle.padding;
      const pb = dropdownStyle.paddingIsMixed ? dropdownStyle.paddingBottom : dropdownStyle.padding;
      const pr = (dropdownStyle.paddingIsMixed ? dropdownStyle.paddingRight : dropdownStyle.padding) + (dropdownArrow ? dropdownArrow.size + dropdownArrow.gap : 0);
      const dropdownRadius = dropdownStyle.radiusIsMixed ? `${dropdownStyle.radiusTopLeft}px ${dropdownStyle.radiusTopRight}px ${dropdownStyle.radiusBottomRight}px ${dropdownStyle.radiusBottomLeft}px` : `${dropdownStyle.radius}px`;
      layers.push(/* @__PURE__ */ _jsxs("select", { className: "superfields-dropdown", value: fieldType2 == FilterFieldType.Toggle ? { true: "on", false: "off", null: ALL_SELECTED_VALUE }[String(value)] : value || (allOption ? ALL_SELECTED_VALUE : defaultValue), onChange: (event) => {
        if (fieldType2 == FilterFieldType.Toggle) {
          setFilter(TOGGLE_VALUES[event.target.value]);
        } else {
          setFilter(event.target.value == ALL_SELECTED_VALUE ? null : event.target.value);
        }
      }, style: { position: "relative", appearance: "none", height: "100%", cursor: "pointer", ...createBackground(dropdownStyle.fill), color: dropdownStyle.fontColor, padding: `${pt}px ${pr}px ${pb}px ${pl}px`, borderRadius: dropdownRadius, border: "none", boxShadow: dropdownStyle.shadows, ...props.font, ...props.style }, children: [allOption && /* @__PURE__ */ _jsx("option", { value: ALL_SELECTED_VALUE, children: fieldType2 == FilterFieldType.Toggle ? toggleMultiOptions.allText : options.allText }), optionItems.map((item, index) => item === DIVIDER ? /* @__PURE__ */ _jsx("hr", {}) : /* @__PURE__ */ _jsx("option", { value: item.value, children: item.text }, index))] }), dropdownStyle.border && /* @__PURE__ */ _jsx(Border, { ...dropdownStyle.border, radius: dropdownRadius }));
      if (dropdownArrow) {
        var _dropdownArrow_color;
        layers.push(/* @__PURE__ */ _jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: dropdownArrow.size, height: dropdownArrow.size, viewBox: "0 0 18 18", fill: "none", strokeWidth: dropdownArrow.stroke, stroke: (_dropdownArrow_color = dropdownArrow.color) !== null && _dropdownArrow_color !== void 0 ? _dropdownArrow_color : dropdownStyle.fontColor, strokeLinecap: "round", strokeLinejoin: "round", style: { display: "block", position: "absolute", right: dropdownStyle.paddingIsMixed ? dropdownStyle.paddingRight : dropdownStyle.padding, top: `calc(50% - ${dropdownArrow.size / 2}px)`, pointerEvents: "none" }, children: /* @__PURE__ */ _jsx("path", { d: "M2 5.5L9 12.5L16 5.5" }) }));
      }
      break;
    case "buttonGroup":
      var _props_font;
      layers.push(/* @__PURE__ */ _jsxs("div", { style: { display: "flex", flexDirection: buttonGroupLayout.direction == "horizontal" ? "row" : "column", flexWrap: buttonGroupLayout.wrap ? "wrap" : "nowrap", justifyContent: buttonGroupLayout.distribute, columnGap: buttonGroupLayout.gapH, rowGap: buttonGroupLayout.gapV, textAlign: ((_props_font = props.font) === null || _props_font === void 0 ? void 0 : _props_font.textAlign) || "center", ...props.style }, children: [allOption && /* @__PURE__ */ _jsx(FilterButton, { selected: value == null, onClick: () => setFilter(null), text: options.allText, direction: buttonGroupLayout.direction, width: buttonGroupLayout.width, transition, ...buttonGroupStyle }), optionItems.map((item, index) => item === DIVIDER ? /* @__PURE__ */ _jsx(ButtonGroupDivider, { ...props.dividerStyle, layout: buttonGroupLayout }) : /* @__PURE__ */ _jsx(FilterButton, { selected: fieldType2 == FilterFieldType.Toggle ? value == (item.value == "on") : props.multiSelect ? value ? value.split(DELIMITER).includes(item.value) : false : value == item.value, onClick: () => {
        if (fieldType2 == FilterFieldType.Toggle) {
          setFilter(item.value == "on");
        } else if (props.multiSelect) {
          if (!value) {
            setFilter(item.value);
          } else {
            const values = value ? value.split(DELIMITER) : [];
            if (value == item.value) {
              if (options.allOption || !defaultOptionIsValid) {
                setFilter(null);
              }
            } else if (values.includes(item.value)) {
              setFilter(values.filter((v) => v != item.value).join(DELIMITER));
            } else {
              setFilter(`${value}${DELIMITER}${item.value}`);
            }
          }
        } else {
          if (value == item.value && (!defaultOptionIsValid || options.allOption)) {
            setFilter(null);
          } else {
            setFilter(item.value);
          }
        }
      }, text: item.text, direction: buttonGroupLayout.direction, width: buttonGroupLayout.width, transition, ...buttonGroupStyle }, index))] }));
      break;
    case "toggleSwitch":
      const { height, padding, border, switchBorder } = toggleSwitchStyle;
      return /* @__PURE__ */ _jsxs("div", { onClick: () => setFilter(value == onValue ? offValue : onValue), style: { display: "flex", flexDirection: (toggleTwoStateText === null || toggleTwoStateText === void 0 ? void 0 : toggleTwoStateText.location) == "left" ? "row-reverse" : "row", gap: toggleTwoStateText === null || toggleTwoStateText === void 0 ? void 0 : toggleTwoStateText.gap, alignItems: "center", justifyContent: LAYOUT_ALIGNMENTS[layout], cursor: "pointer", ...props.style }, children: [/* @__PURE__ */ _jsxs(motion.div, { animate: { ...createBackground(toggleSwitchStyle.fill, value == onValue) }, style: { position: "relative", height, width: height * 2 - padding * 2, padding, borderRadius: toggleSwitchStyle.radius }, initial: false, transition, children: [border && /* @__PURE__ */ _jsx(motion.div, { animate: { borderColor: value == onValue ? border.colorOn : border.colorOff }, style: { position: "absolute", inset: 0, boxSizing: "border-box", borderRadius: toggleSwitchStyle.radius, borderWidth: border.width, borderStyle: border.style }, initial: false, transition }), /* @__PURE__ */ _jsx(motion.div, {
        animate: { translateX: value == onValue ? "100%" : "0%", ...createBackground(toggleSwitchStyle.switchFill, value == onValue) },
        style: { position: "absolute", height: height - padding * 2, aspectRatio: 1, left: padding, borderRadius: toggleSwitchStyle.radius - padding, boxShadow: toggleSwitchStyle.shadows, boxSizing: "border-box" },
        // layout
        initial: false,
        transition,
        children: switchBorder && /* @__PURE__ */ _jsx(motion.div, { animate: { borderColor: value == onValue ? switchBorder.colorOn : switchBorder.colorOff }, style: { position: "absolute", inset: 0, boxSizing: "border-box", borderRadius: toggleSwitchStyle.radius - padding, borderWidth: switchBorder.width, borderStyle: switchBorder.style }, initial: false, transition })
      })] }), toggleTwoStateText && /* @__PURE__ */ _jsx("p", { style: { color: toggleTwoStateText.fontColor, margin: 0, userSelect: "none", flex: layout == "fill" ? 1 : void 0, ...props.font }, children: value == onValue ? toggleTwoStateText.onText : toggleTwoStateText.offText })] });
      break;
    case "checkbox":
      var _checkboxStyle_icon;
      var _checkboxStyle_fillOn, _checkboxStyle_fillOff;
      layers.push(/* @__PURE__ */ _jsxs("div", { onClick: () => setFilter(value == onValue ? offValue : onValue), style: { display: "flex", flexDirection: (toggleTwoStateText === null || toggleTwoStateText === void 0 ? void 0 : toggleTwoStateText.location) == "left" ? "row-reverse" : "row", gap: toggleTwoStateText === null || toggleTwoStateText === void 0 ? void 0 : toggleTwoStateText.gap, alignItems: "center", justifyContent: LAYOUT_ALIGNMENTS[layout], cursor: "pointer", ...props.style }, children: [/* @__PURE__ */ _jsx(motion.div, { animate: { backgroundColor: value == onValue ? (_checkboxStyle_fillOn = checkboxStyle.fillOn) !== null && _checkboxStyle_fillOn !== void 0 ? _checkboxStyle_fillOn : "transparent" : (_checkboxStyle_fillOff = checkboxStyle.fillOff) !== null && _checkboxStyle_fillOff !== void 0 ? _checkboxStyle_fillOff : "transparent", color: (_checkboxStyle_icon = checkboxStyle.icon) === null || _checkboxStyle_icon === void 0 ? void 0 : _checkboxStyle_icon.colorOn }, style: { display: "flex", justifyContent: "center", alignItems: "center", width: checkboxStyle.size, height: checkboxStyle.size, borderRadius: checkboxStyle.radius, position: "relative" }, initial: false, transition, children: checkboxStyle.icon && /* @__PURE__ */ _jsx(motion.svg, { xmlns: "http://www.w3.org/2000/svg", width: checkboxStyle.icon.size, height: checkboxStyle.icon.size, viewBox: "0 0 24 24", strokeWidth: checkboxStyle.icon.lineWidth * (24 / checkboxStyle.icon.size), stroke: "currentColor", fill: "none", strokeLinecap: checkboxStyle.icon.rounded ? "round" : "butt", strokeLinejoin: checkboxStyle.icon.rounded ? "round" : "miter", animate: { opacity: value == onValue ? 1 : 0 }, style: { display: "block" }, initial: false, transition, children: /* @__PURE__ */ _jsx("path", { d: "M5 12l5 5l10 -10" }) }) }), toggleTwoStateText && /* @__PURE__ */ _jsx("p", { style: { color: toggleTwoStateText.fontColor, margin: 0, userSelect: "none", flex: layout == "fill" ? 1 : void 0, ...props.font }, children: value == onValue ? toggleTwoStateText.onText : toggleTwoStateText.offText })] }));
      break;
  }
  return /* @__PURE__ */ _jsx("div", { "data-superfields": true, style: { position: "relative", userSelect: "none", ...props.font, ...props.style }, children: layers });
}
var Filter = withCSS(FilterComponent, ["select.superfields-dropdown:focus-visible { outline: none; }"], "superfields-filter");
var stdin_default3 = Filter;
var paddingRadiusProps = { padding: { type: ControlType.FusedNumber, defaultValue: 16, toggleKey: "paddingIsMixed", toggleTitles: ["All", "Individual"], valueKeys: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"], valueLabels: ["T", "R", "B", "L"], min: 0 }, radius: { type: ControlType.FusedNumber, defaultValue: 8, toggleKey: "radiusIsMixed", toggleTitles: ["All", "Individual"], valueKeys: ["radiusTopLeft", "radiusTopRight", "radiusBottomRight", "radiusBottomLeft"], valueLabels: ["TL", "TR", "BR", "BL"], min: 0 } };
addPropertyControls(Filter, { ...superfieldsId(), filterBy: { type: ControlType.Enum, defaultValue: "field", options: ["field", "favourites"], optionTitles: ["CMS Field", "Favourites"], displaySegmentedControl: true, segmentedControlDirection: "vertical" }, fieldType: { type: ControlType.Enum, defaultValue: FilterFieldType.Option, options: [FilterFieldType.Option, FilterFieldType.Toggle, FilterFieldType.Text, FilterFieldType.Reference, FilterFieldType.MultiReference, FilterFieldType.MultipleOptions], optionTitles: ["Option", "Toggle", "Text", "Reference", "Multi-Reference", "Multiple Options"], hidden: (props) => props.filterBy != "field" }, fieldName: { type: ControlType.String, defaultValue: "", placeholder: "CMS Field Name", hidden: (props) => props.filterBy !== "field" || props.fieldType === FilterFieldType.MultipleOptions }, referenceFieldType: { type: ControlType.Enum, defaultValue: FilterFieldType.Text, options: [FilterFieldType.Option, FilterFieldType.Toggle, FilterFieldType.Text], optionTitles: ["Option", "Toggle", "Text"], hidden: (props) => props.filterBy !== "field" || !isReferenceType(props.fieldType) }, referenceFieldName: { type: ControlType.String, defaultValue: "Title", placeholder: "Reference CMS Field Name", hidden: (props) => props.filterBy !== "field" || !isReferenceType(props.fieldType) }, optionFieldNames: { type: ControlType.Array, title: "Field Names", control: { type: ControlType.String, defaultValue: "", placeholder: "CMS Field Name" }, hidden: (props) => props.filterBy !== "field" || props.fieldType !== FilterFieldType.MultipleOptions }, filterTypeOption: { type: ControlType.Enum, defaultValue: "dropdown", options: ["dropdown", "buttonGroup"], optionTitles: ["Dropdown", "Buttons"], displaySegmentedControl: true, segmentedControlDirection: "vertical", title: "Type", hidden: (props) => !isOptionType(props) }, filterTypeToggle: { type: ControlType.Enum, defaultValue: "toggleSwitch", options: ["toggleSwitch", "checkbox", "dropdown", "buttonGroup"], optionTitles: ["Toggle Switch", "Checkbox", "Dropdown", "Buttons"], title: "Type", hidden: (props) => fieldType(props) != FilterFieldType.Toggle }, options: { type: ControlType.Object, controls: { defaultValue: { type: ControlType.String, defaultValue: "", placeholder: "Default Value" }, optionMode: { type: ControlType.Enum, defaultValue: "auto", options: ["manual", "auto"], optionTitles: ["Manual", "Auto"], displaySegmentedControl: true, title: "Options" }, optionValues: { type: ControlType.Array, title: " ", control: { type: ControlType.String, defaultValue: "" }, hidden: (props) => props.optionMode !== "manual" }, optionOrder: { type: ControlType.Enum, defaultValue: "default", options: ["default", "alphabetical"], optionTitles: ["Default", "Alphabetical"], displaySegmentedControl: true, segmentedControlDirection: "vertical", title: "Order", description: "Connect the collection list to enable auto options.", hidden: (props) => props.optionMode !== "auto" }, placeholder: { type: ControlType.String, defaultValue: "[Preview project]", hidden: (props) => props.optionMode !== "auto" }, allOption: { type: ControlType.Boolean, defaultValue: true, enabledTitle: "Show", disabledTitle: "Hide" }, allText: { type: ControlType.String, defaultValue: "All", title: " ", hidden: (props) => !props.allOption } }, hidden: (props) => !isOptionType(props) }, textCondition: { type: ControlType.Enum, defaultValue: FilterTextCondition.Equals, options: [FilterTextCondition.Equals, FilterTextCondition.Contains], optionTitles: ["Equals", "Contains"], displaySegmentedControl: true, title: "Condition", hidden: (props) => !CONDITION_FIELD_TYPES.includes(fieldType(props)) || props.options.optionMode !== "manual" }, multipleOptionsNoneOption: { type: ControlType.String, defaultValue: "", placeholder: "None Option Name", title: "None Option", hidden: (props) => props.fieldType !== FilterFieldType.MultipleOptions }, collectionList: { type: ControlType.ComponentInstance, hidden: (props) => !isOptionType(props) || props.options.optionMode != "auto" }, toggleMultiOptions: { type: ControlType.Object, title: "Options", controls: { defaultValue: { type: ControlType.Enum, defaultValue: null, options: ["all", "on", "off"], optionTitles: ["All", "Yes", "No"], displaySegmentedControl: true }, allOption: { type: ControlType.Boolean, defaultValue: true, enabledTitle: "Show", disabledTitle: "Hide" }, allText: { type: ControlType.String, defaultValue: "All", title: " ", hidden: (props) => !props.allOption }, yesOption: { type: ControlType.Boolean, defaultValue: true, enabledTitle: "Show", disabledTitle: "Hide" }, yesText: { type: ControlType.String, defaultValue: "On", title: " ", hidden: (props) => !props.yesOption }, noOption: { type: ControlType.Boolean, defaultValue: false, enabledTitle: "Show", disabledTitle: "Hide" }, noText: { type: ControlType.String, defaultValue: "Off", title: " ", hidden: (props) => !props.noOption }, order: { type: ControlType.Enum, defaultValue: "yesNo", options: ["yesNo", "noYes"], optionTitles: ["Yes/No", "No/Yes"], displaySegmentedControl: true, hidden: (props) => !props.yesOption || !props.noOption } }, hidden: (props) => fieldType(props) != FilterFieldType.Toggle || filterType(props) != "dropdown" && filterType(props) != "buttonGroup" }, toggleTwoStateOptions: { type: ControlType.Object, title: "Options", icon: "boolean", controls: { defaultValue: { type: ControlType.Enum, defaultValue: "off", options: ["off", "on"], optionTitles: ["Off", "On"], displaySegmentedControl: true }, offState: { type: ControlType.Enum, defaultValue: "all", options: ["all", "on", "off"], optionTitles: ["All Items", "On/True Only", "Off/False Only"], displaySegmentedControl: true, segmentedControlDirection: "vertical" }, onState: { type: ControlType.Enum, defaultValue: "on", options: ["all", "on", "off"], optionTitles: ["All Items", "On/True Only", "Off/False Only"], displaySegmentedControl: true, segmentedControlDirection: "vertical" } }, hidden: (props) => fieldType(props) != FilterFieldType.Toggle || filterType(props) != "toggleSwitch" && filterType(props) != "checkbox" }, toggleTwoStateText: { type: ControlType.Object, optional: true, defaultValue: { offText: "Off", onText: "On", location: "right", gap: 10 }, title: "Text", controls: { offText: { type: ControlType.String, defaultValue: "Off" }, onText: { type: ControlType.String, defaultValue: "On" }, fontColor: { type: ControlType.Color, defaultValue: "#000" }, location: { type: ControlType.Enum, defaultValue: "right", options: ["left", "right"], optionTitles: ["Left", "Right"], displaySegmentedControl: true }, gap: { type: ControlType.Number, defaultValue: 10, min: 0, step: 1 } }, hidden: (props) => fieldType(props) != FilterFieldType.Toggle || filterType(props) != "toggleSwitch" && filterType(props) != "checkbox" }, multiSelect: { type: ControlType.Boolean, defaultValue: false, title: "Multi-Select", hidden: (props) => filterType(props) != "buttonGroup" || fieldType(props) == FilterFieldType.Toggle }, font: { type: ControlType.Font, controls: "extended", defaultFontType: "sans-serif", defaultValue: { fontSize: 14, lineHeight: 1.4 } }, buttonGroupStyle: { type: ControlType.Object, title: "Buttons", buttonTitle: "Styles", controls: { fill: fillPropOnOff({ colorOff: "#F0F0F0", colorAOff: "#EDEDED", colorBOff: "#CCC", colorOn: "#0075FF", colorAOn: "#70B3FF", colorBOn: "#0075FF" }), selectedFontColor: { type: ControlType.Color, defaultValue: "#FFF", title: "Font Color On" }, defaultFontColor: { type: ControlType.Color, defaultValue: "#000", title: "Font Color Off" }, ...paddingRadiusProps, border: { type: ControlType.Object, optional: true, controls: { selectedColor: { type: ControlType.Color, defaultValue: "#0051ad", title: "Color On" }, defaultColor: { type: ControlType.Color, defaultValue: "#222", title: "Color Off" }, width: { type: ControlType.FusedNumber, defaultValue: 1, toggleKey: "widthIsMixed", toggleTitles: ["All", "Individual"], valueKeys: ["widthTop", "widthRight", "widthBottom", "widthLeft"], valueLabels: ["T", "R", "B", "L"], min: 0 }, style: { type: ControlType.Enum, defaultValue: "solid", options: ["solid", "dashed", "dotted", "double"], optionTitles: ["Solid", "Dashed", "Dotted", "Double"] } } }, shadowsSelected: { type: ControlType.BoxShadow, title: "Shadow On" }, shadows: { type: ControlType.BoxShadow, title: "Shadow Off" } }, hidden: (props) => filterType(props) != "buttonGroup" }, buttonGroupLayout: { type: ControlType.Object, title: "Layout", buttonTitle: "Stack", controls: { direction: { type: ControlType.Enum, defaultValue: "horizontal", options: ["horizontal", "vertical"], displaySegmentedControl: true }, distribute: { type: ControlType.Enum, defaultValue: "center", options: ["flex-start", "center", "flex-end", "space-between", "space-around", "space-evenly"], optionTitles: ["Start", "Center", "End", "Space Between", "Space Around", "Space Evenly"] }, wrap: { type: ControlType.Boolean, defaultValue: false }, gapH: { type: ControlType.Number, defaultValue: 8, min: 0, step: 1 }, gapV: { type: ControlType.Number, defaultValue: 8, min: 0, step: 1 }, width: { type: ControlType.Enum, defaultValue: "fit", options: ["fit", "fill"], optionTitles: ["Fit", "Fill"], displaySegmentedControl: true } }, hidden: (props) => filterType(props) != "buttonGroup" }, dividerStyle: { type: ControlType.Object, title: "Dividers", controls: { color: { type: ControlType.Color, defaultValue: "rgba(0, 0, 0, 0.25)" }, width: { type: ControlType.Number, defaultValue: 1, min: 0, displayStepper: true }, rounded: { type: ControlType.Boolean, defaultValue: false }, marginH: { type: ControlType.Number, defaultValue: 0, min: 0, step: 1, displayStepper: true }, marginV: { type: ControlType.Number, defaultValue: 0, min: 0, step: 1, displayStepper: true, description: "Add a divider by using *---* as an option name" } }, hidden: (props) => filterType(props) != "buttonGroup" || fieldType(props) != FilterFieldType.Option && fieldType(props) != FilterFieldType.Text || props.options.optionMode !== "manual" }, dropdownStyle: { type: ControlType.Object, title: "Dropdown", buttonTitle: "Styles", controls: { fill: fillProp({ color: "#F0F0F0" }), fontColor: { type: ControlType.Color, defaultValue: "#000" }, ...paddingRadiusProps, arrow: { type: ControlType.Object, defaultValue: { size: 12, gap: 10 }, optional: true, buttonTitle: "Style", controls: { color: { type: ControlType.Color, optional: true }, size: { type: ControlType.Number, defaultValue: 12, min: 1, step: 1 }, gap: { type: ControlType.Number, defaultValue: 10, min: 0, step: 1 }, stroke: { type: ControlType.Number, defaultValue: 2, min: 0.1, step: 0.1, displayStepper: true } } }, border: borderPropertyControl(), shadows: { type: ControlType.BoxShadow } }, hidden: (props) => filterType(props) != "dropdown" }, toggleSwitchStyle: { type: ControlType.Object, title: "Toggle Switch", buttonTitle: "Styles", icon: "boolean", controls: { fill: fillPropOnOff({ colorOn: "#0075FF", colorAOn: "#70B3FF", colorBOn: "#0075FF", colorOff: "#EDEDED", colorAOff: "#EDEDED", colorBOff: "#CCC" }), border: { type: ControlType.Object, optional: true, controls: { colorOn: { type: ControlType.Color, defaultValue: "#222" }, colorOff: { type: ControlType.Color, defaultValue: "#222" }, width: { type: ControlType.Number, defaultValue: 1, min: 0, step: 1 }, style: { type: ControlType.Enum, defaultValue: "solid", options: ["solid", "dashed", "dotted", "double"], optionTitles: ["Solid", "Dashed", "Dotted", "Double"] } } }, switchFill: fillPropOnOff({ colorOn: "#FFF", colorAOn: "#FFF", colorBOn: "#D6D6D6", colorOff: "#FFF", colorAOff: "#FFF", colorBOff: "#D6D6D6" }), switchBorder: { type: ControlType.Object, optional: true, controls: { colorOn: { type: ControlType.Color, defaultValue: "#222" }, colorOff: { type: ControlType.Color, defaultValue: "#222" }, width: { type: ControlType.Number, defaultValue: 1, min: 0, step: 1 }, style: { type: ControlType.Enum, defaultValue: "solid", options: ["solid", "dashed", "dotted", "double"], optionTitles: ["Solid", "Dashed", "Dotted", "Double"] } } }, shadows: { type: ControlType.BoxShadow, defaultValue: "0px 2px 4px 0px rgba(0,0,0,0.2)" }, height: { type: ControlType.Number, defaultValue: 32, min: 1, step: 1 }, padding: { type: ControlType.Number, defaultValue: 4, min: 0, step: 1, displayStepper: true }, radius: { type: ControlType.Number, defaultValue: 16, min: 0 } }, hidden: (props) => filterType(props) != "toggleSwitch" }, checkboxStyle: { type: ControlType.Object, title: "Checkbox", buttonTitle: "Styles", controls: { fillOn: { type: ControlType.Color, defaultValue: "#0075FF" }, fillOff: { type: ControlType.Color, defaultValue: "#EDEDED" }, size: { type: ControlType.Number, defaultValue: 24, min: 1, step: 1 }, radius: { type: ControlType.Number, defaultValue: 6, min: 0 }, icon: { type: ControlType.Object, optional: true, defaultValue: { size: 16, color: "#FFF", rounded: true }, buttonTitle: "Options", controls: { size: { type: ControlType.Number, defaultValue: 16, min: 1, step: 1 }, lineWidth: { type: ControlType.Number, defaultValue: 2, min: 1, step: 0.1 }, colorOn: { type: ControlType.Color, defaultValue: "#FFF", title: "Color" }, rounded: { type: ControlType.Boolean, defaultValue: true } } } }, hidden: (props) => filterType(props) != "checkbox" }, transition: { type: ControlType.Transition, defaultValue: { type: "spring", duration: 0.2, bounce: 0 }, hidden: (props) => filterType(props) == "dropdown" } });
var isReferenceType = (fieldType2) => fieldType2 === FilterFieldType.Reference || fieldType2 === FilterFieldType.MultiReference;
function filterType(props) {
  if (props.filterBy == "field") {
    const type = isReferenceType(props.fieldType) ? props.referenceFieldType : props.fieldType;
    if (type == FilterFieldType.Toggle) {
      return props.filterTypeToggle;
    } else {
      return props.filterTypeOption;
    }
  } else {
    return props.filterTypeToggle;
  }
}
function fieldType(props) {
  if (props.filterBy == "field") {
    const type = isReferenceType(props.fieldType) ? props.referenceFieldType : props.fieldType;
    return type === FilterFieldType.MultipleOptions ? FilterFieldType.Option : type;
  } else {
    return FilterFieldType.Toggle;
  }
}
function isOptionType(props) {
  if (props.filterBy == "field") {
    if (isReferenceType(props.fieldType)) {
      return props.referenceFieldType == FilterFieldType.Option || props.referenceFieldType == FilterFieldType.Text;
    } else {
      return props.fieldType == FilterFieldType.Option || props.fieldType == FilterFieldType.Text || props.fieldType == FilterFieldType.MultipleOptions;
    }
  } else {
    return false;
  }
}
function isDivider(text) {
  return text ? DASHES_ONLY_REGEX.test(text) && text.length >= 3 : false;
}
function FilterButton(props) {
  const { selected, border } = props;
  return /* @__PURE__ */ _jsxs(motion.div, { onClick: props.onClick, animate: { ...createBackground(props.fill, selected), color: selected ? props.selectedFontColor : props.defaultFontColor, boxShadow: selected && props.shadowsSelected ? props.shadowsSelected : props.shadows }, style: { position: "relative", width: props.direction == "vertical" && props.width == "fill" ? "100%" : "max-content", flex: props.width == "fill" ? 1 : void 0, cursor: "pointer", padding: props.paddingIsMixed ? `${props.paddingTop}px ${props.paddingRight}px ${props.paddingBottom}px ${props.paddingLeft}px` : `${props.padding}px`, borderRadius: props.radiusIsMixed ? `${props.radiusTopLeft}px ${props.radiusTopRight}px ${props.radiusBottomRight}px ${props.radiusBottomLeft}px` : `${props.radius}px` }, initial: false, transition: props.transition, children: [props.text, border && /* @__PURE__ */ _jsx(Border, { ...border, color: selected ? border.selectedColor : border.defaultColor, transition: props.transition })] });
}
function ButtonGroupDivider({ color, width, rounded, marginH, marginV, layout }) {
  const horizontal = layout.direction == "vertical";
  return /* @__PURE__ */ _jsx("div", { style: { backgroundColor: color, width: horizontal ? void 0 : width, height: horizontal ? width : void 0, margin: `${marginV}px ${marginH}px`, borderRadius: rounded ? 1e4 : void 0, alignSelf: "stretch" } });
}

// /:https://framerusercontent.com/modules/omo5LdjL4LRSZXvwvWOk/u3WxIJnBoahCGbEeALvk/O_XoZ3FcZ.js
import { jsx as _jsx2 } from "react/jsx-runtime";
import { addFonts, addPropertyControls as addPropertyControls2, ControlType as ControlType2, cx, useComponentViewport, useLocaleInfo, useVariantState, withCSS as withCSS2, withFX } from "unframer";
import { LayoutGroup, motion as motion2, MotionConfigContext } from "unframer";
import * as React from "react";
var MotionDivWithFX = withFX(motion2.div);
var cycleOrder = ["G47S15YSn", "PX1MOnVXY"];
var serializationHash = "framer-8EaGQ";
var variantClassNames = { G47S15YSn: "framer-v-1hbo82m", PX1MOnVXY: "framer-v-17k3l76" };
var transition1 = { duration: 0, type: "tween" };
var animation = { opacity: 0, rotate: 0, rotateX: 0, rotateY: 0, scale: 1, skewX: 0, skewY: 0, x: 0, y: 0 };
var transition2 = { delay: 0, duration: 0.3, ease: [0.44, 0, 0.56, 1], type: "tween" };
var animation1 = { opacity: 0, rotate: 0, rotateX: 0, rotateY: 0, scale: 1, skewX: 0, skewY: 0, transition: transition2, x: 0, y: 0 };
var transition3 = { delay: 0, duration: 1, ease: [0, 0, 1, 1], type: "tween" };
var animation2 = { opacity: 1, rotate: 360, rotateX: 0, rotateY: 0, scale: 1, skewX: 0, skewY: 0, x: 0, y: 0 };
var Transition = ({ value, children }) => {
  const config = React.useContext(MotionConfigContext);
  const transition = value !== null && value !== void 0 ? value : config.transition;
  const contextValue = React.useMemo(() => ({ ...config, transition }), [JSON.stringify(transition)]);
  return /* @__PURE__ */ _jsx2(MotionConfigContext.Provider, { value: contextValue, children });
};
var Variants = motion2(React.Fragment);
var humanReadableVariantMap = { Hidden: "PX1MOnVXY", Loading: "G47S15YSn" };
var getProps = ({ height, id, width, ...props }) => {
  var _humanReadableVariantMap_props_variant, _ref;
  return { ...props, variant: (_ref = (_humanReadableVariantMap_props_variant = humanReadableVariantMap[props.variant]) !== null && _humanReadableVariantMap_props_variant !== void 0 ? _humanReadableVariantMap_props_variant : props.variant) !== null && _ref !== void 0 ? _ref : "G47S15YSn" };
};
var createLayoutDependency = (props, variants) => {
  if (props.layoutDependency) return variants.join("-") + props.layoutDependency;
  return variants.join("-");
};
var Component = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  const { activeLocale, setLocale } = useLocaleInfo();
  const { style, className: className2, layoutId, variant, ...restProps } = getProps(props);
  const { baseVariant, classNames, gestureHandlers, gestureVariant, setGestureState, setVariant, variants } = useVariantState({ cycleOrder, defaultVariant: "G47S15YSn", variant, variantClassNames });
  const layoutDependency = createLayoutDependency(props, variants);
  const isDisplayed = () => {
    if (baseVariant === "PX1MOnVXY") return false;
    return true;
  };
  const ref1 = React.useRef(null);
  const defaultLayoutId = React.useId();
  const sharedStyleClassNames = [];
  const componentViewport = useComponentViewport();
  return /* @__PURE__ */ _jsx2(LayoutGroup, { id: layoutId !== null && layoutId !== void 0 ? layoutId : defaultLayoutId, children: /* @__PURE__ */ _jsx2(Variants, { animate: variants, initial: false, children: isDisplayed() && /* @__PURE__ */ _jsx2(Transition, { value: transition1, children: /* @__PURE__ */ _jsx2(motion2.div, { ...restProps, ...gestureHandlers, className: cx(serializationHash, ...sharedStyleClassNames, "framer-1hbo82m", className2, classNames), "data-framer-name": "Loading", layoutDependency, layoutId: "G47S15YSn", ref: ref !== null && ref !== void 0 ? ref : ref1, style: { ...style }, children: /* @__PURE__ */ _jsx2(MotionDivWithFX, { __framer__animate: { transition: transition2 }, __framer__animateOnce: false, __framer__enter: animation, __framer__exit: animation1, __framer__styleAppearEffectEnabled: true, __framer__threshold: 0.5, __perspectiveFX: false, __smartComponentFX: true, __targetOpacity: 1, className: "framer-1qrc6yg", "data-framer-name": "Spinner", layoutDependency, layoutId: "onOQ0YrdY", style: { mask: "url('https://framerusercontent.com/images/pGiXYozQ3mE4cilNOItfe2L2fUA.svg') alpha no-repeat center / cover add", WebkitMask: "url('https://framerusercontent.com/images/pGiXYozQ3mE4cilNOItfe2L2fUA.svg') alpha no-repeat center / cover add" }, children: /* @__PURE__ */ _jsx2(MotionDivWithFX, { __framer__loop: animation2, __framer__loopEffectEnabled: true, __framer__loopRepeatDelay: 0, __framer__loopRepeatType: "loop", __framer__loopTransition: transition3, __perspectiveFX: false, __smartComponentFX: true, __targetOpacity: 1, className: "framer-1jivlv8", "data-framer-name": "Conic", layoutDependency, layoutId: "rN6xsA2D3", style: { background: "conic-gradient(from 0deg at 50% 50%, rgba(255, 255, 255, 0) 0deg, rgb(153, 153, 153) 342deg)" }, children: /* @__PURE__ */ _jsx2(motion2.div, { className: "framer-m7b4s7", "data-framer-name": "Round", layoutDependency, layoutId: "KWLYXFUsw", style: { backgroundColor: "rgb(153, 153, 153)", borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1 } }) }) }) }) }) }) });
});
var css2 = ["@supports (aspect-ratio: 1) { body { --framer-aspect-ratio-supported: auto; } }", ".framer-8EaGQ.framer-xuzmjz, .framer-8EaGQ .framer-xuzmjz { display: block; }", ".framer-8EaGQ.framer-1hbo82m { align-content: center; align-items: center; display: flex; flex-direction: row; flex-wrap: nowrap; gap: 10px; height: 40px; justify-content: center; padding: 0px; position: relative; width: 40px; }", ".framer-8EaGQ .framer-1qrc6yg { aspect-ratio: 1 / 1; flex: none; height: var(--framer-aspect-ratio-supported, 20px); overflow: visible; position: relative; width: 20px; }", ".framer-8EaGQ .framer-1jivlv8 { bottom: 0px; flex: none; left: 0px; overflow: visible; position: absolute; right: 0px; top: 0px; }", ".framer-8EaGQ .framer-m7b4s7 { flex: none; height: 2px; left: calc(50.00000000000002% - 2px / 2); overflow: visible; position: absolute; top: 0px; width: 2px; }", "@supports (background: -webkit-named-image(i)) and (not (font-palette:dark)) { .framer-8EaGQ.framer-1hbo82m { gap: 0px; } .framer-8EaGQ.framer-1hbo82m > * { margin: 0px; margin-left: calc(10px / 2); margin-right: calc(10px / 2); } .framer-8EaGQ.framer-1hbo82m > :first-child { margin-left: 0px; } .framer-8EaGQ.framer-1hbo82m > :last-child { margin-right: 0px; } }"];
var FramerO_XoZ3FcZ = withCSS2(Component, css2, "framer-8EaGQ");
var stdin_default4 = FramerO_XoZ3FcZ;
FramerO_XoZ3FcZ.displayName = "Spinner";
FramerO_XoZ3FcZ.defaultProps = { height: 40, width: 40 };
addPropertyControls2(FramerO_XoZ3FcZ, { variant: { options: ["G47S15YSn", "PX1MOnVXY"], optionTitles: ["Loading", "Hidden"], title: "Variant", type: ControlType2.Enum } });
addFonts(FramerO_XoZ3FcZ, [{ explicitInter: true, fonts: [] }], { supportsExplicitInterCodegen: true });

// /:https://framerusercontent.com/modules/zih4XvD9VgCbMfkxqsdD/W8EvxVLii4iAJgYjBoCK/uSJVhQSyB.js
var FilterFonts = getFonts(stdin_default3);
var SearchBarFonts = getFonts(SearchBar);
var SpinnerFonts = getFonts(stdin_default4);
var MotionDivWithInfiniteScroll = withInfiniteScroll(motion3.div);
var SuperfieldsFonts = getFonts(Superfields);
var serializationHash2 = "framer-leZ5S";
var variantClassNames2 = { kYbkwCmoa: "framer-v-x2v1em" };
var transition12 = { bounce: 0.2, delay: 0, duration: 0.4, type: "spring" };
var loaderVariants = (repeaterState, variants, currentVariant) => {
  if (repeaterState.currentPage >= repeaterState.totalPages) return variants.disabled ?? currentVariant;
  if (repeaterState.isLoading) return variants.loading ?? currentVariant;
  return currentVariant;
};
var QueryData = ({ query: query2, pageSize, children }) => {
  const { paginatedQuery, paginationInfo, loadMore } = useLoadMorePaginatedQuery(query2, pageSize, "amnlWJ0bR");
  const data = useQueryData2(paginatedQuery);
  return children(data, paginationInfo, loadMore);
};
var Transition2 = ({ value, children }) => {
  const config = React2.useContext(MotionConfigContext2);
  const transition = value ?? config.transition;
  const contextValue = React2.useMemo(() => ({ ...config, transition }), [JSON.stringify(transition)]);
  return /* @__PURE__ */ _jsx3(MotionConfigContext2.Provider, { value: contextValue, children });
};
var Variants2 = motion3.create(React2.Fragment);
var getProps2 = ({ height, id, width, ...props }) => {
  return { ...props };
};
var createLayoutDependency2 = (props, variants) => {
  if (props.layoutDependency) return variants.join("-") + props.layoutDependency;
  return variants.join("-");
};
var Component2 = /* @__PURE__ */ React2.forwardRef(function(props, ref) {
  const { activeLocale, setLocale } = useLocaleInfo2();
  const { style, className: className2, layoutId, variant, kPmEwBKSLamnlWJ0bR, niP5RIolcamnlWJ0bR, idamnlWJ0bR, ...restProps } = getProps2(props);
  const { baseVariant, classNames, clearLoadingGesture, gestureHandlers, gestureVariant, isLoading, setGestureState, setVariant, variants } = useVariantState2({ defaultVariant: "kYbkwCmoa", variant, variantClassNames: variantClassNames2 });
  const layoutDependency = createLayoutDependency2(props, variants);
  const sharedStyleClassNames = [className];
  const scopingClassNames = cx2(serializationHash2, ...sharedStyleClassNames);
  const ref1 = React2.useRef(null);
  const dynamicRef = useDynamicRefs();
  const defaultLayoutId = React2.useId();
  const componentViewport = useComponentViewport2();
  return /* @__PURE__ */ _jsx3(LayoutGroup2, { id: layoutId ?? defaultLayoutId, children: /* @__PURE__ */ _jsx3(Variants2, { animate: variants, initial: false, children: /* @__PURE__ */ _jsx3(Transition2, { value: transition12, children: /* @__PURE__ */ _jsxs2(motion3.div, { ...restProps, ...gestureHandlers, className: cx2(scopingClassNames, "framer-x2v1em", className2, classNames), "data-framer-name": "Variant 1", layoutDependency, layoutId: "kYbkwCmoa", ref: ref ?? ref1, style: { backgroundColor: "rgb(255, 255, 255)", ...style }, children: [/* @__PURE__ */ _jsxs2(motion3.div, { className: "framer-1xavbf3", layoutDependency, layoutId: "WM3q5dNJW", children: [/* @__PURE__ */ _jsx3(ComponentViewportProvider, { children: /* @__PURE__ */ _jsx3(motion3.div, { className: "framer-bmisar-container", layoutDependency, layoutId: "A8dJ9B4hT-container", children: /* @__PURE__ */ _jsx3(stdin_default3, { buttonGroupLayout: { direction: "horizontal", distribute: "center", gapH: 8, gapV: 8, width: "fit", wrap: false }, buttonGroupStyle: { defaultFontColor: "rgb(0, 0, 0)", fill: { colorAOff: "rgb(237, 237, 237)", colorAOn: "rgb(112, 179, 255)", colorBOff: "rgb(204, 204, 204)", colorBOn: "rgb(0, 117, 255)", colorOff: "rgb(240, 240, 240)", colorOn: "rgb(0, 117, 255)", gradientAngle: 0, type: "color" }, padding: 16, paddingBottom: 16, paddingIsMixed: false, paddingLeft: 16, paddingRight: 16, paddingTop: 16, radius: 8, radiusBottomLeft: 8, radiusBottomRight: 8, radiusIsMixed: false, radiusTopLeft: 8, radiusTopRight: 8, selectedFontColor: "rgb(255, 255, 255)", shadows: "", shadowsSelected: "" }, checkboxStyle: { fillOff: "rgb(237, 237, 237)", fillOn: "rgb(0, 117, 255)", icon: { colorOn: "rgb(255, 255, 255)", lineWidth: 2, rounded: true, size: 16 }, radius: 6, size: 24 }, collectionList: [], dividerStyle: { color: "rgba(0, 0, 0, 0.25)", marginH: 0, marginV: 0, rounded: false, width: 1 }, dropdownStyle: { arrow: { gap: 10, size: 12, stroke: 2 }, fill: { color: "rgb(240, 240, 240)", colorA: "rgb(255, 255, 255)", colorB: "rgb(189, 189, 189)", gradientAngle: 0, type: "color" }, fontColor: "rgb(0, 0, 0)", padding: 16, paddingBottom: 16, paddingIsMixed: false, paddingLeft: 16, paddingRight: 16, paddingTop: 16, radius: 8, radiusBottomLeft: 8, radiusBottomRight: 8, radiusIsMixed: false, radiusTopLeft: 8, radiusTopRight: 8, shadows: "" }, fieldName: "Favorite", fieldType: "toggle", filterBy: "field", filterTypeOption: "dropdown", filterTypeToggle: "toggleSwitch", font: { fontFamily: '"Inter", sans-serif', fontSize: "14px", fontStyle: "normal", letterSpacing: "0em", lineHeight: "1.4em" }, height: "100%", id: "A8dJ9B4hT", layoutId: "A8dJ9B4hT", multipleOptionsNoneOption: "", multiSelect: false, optionFieldNames: [], options: { allOption: true, allText: "All", defaultValue: "", optionMode: "auto", optionOrder: "default", optionValues: [], placeholder: "[Preview project]" }, referenceFieldName: "Title", referenceFieldType: "text", superfieldsId: 1, textCondition: "equals", toggleMultiOptions: { allOption: true, allText: "All", defaultValue: "all", noOption: false, noText: "Off", order: "yesNo", yesOption: true, yesText: "On" }, toggleSwitchStyle: { fill: { colorAOff: "rgb(237, 237, 237)", colorAOn: "rgb(112, 179, 255)", colorBOff: "rgb(204, 204, 204)", colorBOn: "rgb(0, 117, 255)", colorOff: "rgb(237, 237, 237)", colorOn: "rgb(0, 117, 255)", gradientAngle: 0, type: "color" }, height: 32, padding: 4, radius: 16, shadows: "0px 2px 4px 0px rgba(0,0,0,0.2)", switchFill: { colorAOff: "rgb(255, 255, 255)", colorAOn: "rgb(255, 255, 255)", colorBOff: "rgb(214, 214, 214)", colorBOn: "rgb(214, 214, 214)", colorOff: "rgb(255, 255, 255)", colorOn: "rgb(255, 255, 255)", gradientAngle: 0, type: "color" } }, toggleTwoStateOptions: { defaultValue: "off", offState: "all", onState: "on" }, toggleTwoStateText: { fontColor: "rgb(0, 0, 0)", gap: 10, location: "right", offText: "All", onText: "Favorites" }, transition: { bounce: 0, delay: 0, duration: 0.2, type: "spring" }, width: "100%" }) }) }), /* @__PURE__ */ _jsx3(ComponentViewportProvider, { children: /* @__PURE__ */ _jsx3(motion3.div, { className: "framer-1ch9a9y-container", layoutDependency, layoutId: "TY4uh83jw-container", children: /* @__PURE__ */ _jsx3(SearchBar, { autoFocus: false, fill: { color: "rgb(239, 239, 239)", colorA: "rgb(255, 255, 255)", colorB: "rgb(189, 189, 189)", gradientAngle: 0, type: "color" }, focus: { color: "rgb(0, 117, 255)", style: "solid", transition: { bounce: 0, delay: 0, duration: 0.2, type: "spring" }, width: 2, widthBottom: 2, widthIsMixed: false, widthLeft: 2, widthRight: 2, widthTop: 2 }, font: { fontFamily: '"Inter", sans-serif', fontSize: "14px", fontStyle: "normal", letterSpacing: "0em", lineHeight: "1.4em" }, fontColor: "rgb(0, 0, 0)", gap: 8, height: "100%", id: "TY4uh83jw", layoutId: "TY4uh83jw", padding: "8px 12px 8px 12px", placeholderColor: "rgba(0, 0, 0, 0.5)", placeholderText: "Search [items] items...", radius: "8px", searchIcon: { color: "rgb(0, 0, 0)", lineWidth: 2.5, opacity: 0.5, size: 16 }, shadows: "", style: { width: "100%" }, superfieldsId: 1, width: "100%", xButton: { color: "rgb(0, 0, 0)", lineWidth: 2.5, opacity: 0.5, size: 14 } }) }) })] }), /* @__PURE__ */ _jsx3(ComponentViewportProvider, { children: /* @__PURE__ */ _jsx3(motion3.div, { className: "framer-hsh8lz-container", layoutDependency, layoutId: "vGLIJzFFe-container", children: /* @__PURE__ */ _jsx3(Superfields, { cmsCollectionName: "", collectionList: [/* @__PURE__ */ _jsx3(motion3.div, { className: "framer-1ut4cls", layoutDependency, layoutId: "amnlWJ0bR", children: /* @__PURE__ */ _jsx3(ChildrenCanSuspend, { children: /* @__PURE__ */ _jsx3(QueryData, { pageSize: 1, query: { from: { alias: "amnlWJ0bR", data: stdin_default2, type: "Collection" }, limit: { type: "LiteralValue", value: 10 }, select: [{ collection: "amnlWJ0bR", name: "kPmEwBKSL", type: "Identifier" }, { collection: "amnlWJ0bR", name: "niP5RIolc", type: "Identifier" }, { collection: "amnlWJ0bR", name: "id", type: "Identifier" }] }, children: (collection, paginationInfo, loadMore) => /* @__PURE__ */ _jsxs2(_Fragment, { children: [collection?.map(({ id: idamnlWJ0bR2, kPmEwBKSL: kPmEwBKSLamnlWJ0bR2, niP5RIolc: niP5RIolcamnlWJ0bR2 }, index) => {
    kPmEwBKSLamnlWJ0bR2 ??= "";
    niP5RIolcamnlWJ0bR2 ??= "";
    return /* @__PURE__ */ _jsx3(LayoutGroup2, { id: `amnlWJ0bR-${idamnlWJ0bR2}`, children: /* @__PURE__ */ _jsx3(PathVariablesContext.Provider, { value: { niP5RIolc: niP5RIolcamnlWJ0bR2 }, children: /* @__PURE__ */ _jsx3(motion3.div, { className: "framer-m830a", layoutDependency, layoutId: "m3IXknJcP", children: /* @__PURE__ */ _jsx3(RichText, { __fromCanvasComponent: true, children: /* @__PURE__ */ _jsx3(React2.Fragment, { children: /* @__PURE__ */ _jsx3(motion3.p, { className: "framer-styles-preset-toco2w", "data-styles-preset": "FyeEQTDpS", children: "Title" }) }), className: "framer-1qpnbi7", "data-framer-name": "Title", fonts: ["Inter"], layoutDependency, layoutId: "eMKLL_blU", text: kPmEwBKSLamnlWJ0bR2, verticalAlignment: "top", withExternalLayout: true }) }) }) }, idamnlWJ0bR2);
  }), /* @__PURE__ */ _jsx3(ComponentViewportProvider, { height: 40, children: /* @__PURE__ */ _jsx3(MotionDivWithInfiniteScroll, { __loadMore: loadMore, __paginationInfo: paginationInfo, className: "framer-1n6qscb-container", layoutDependency, layoutId: "UzGzlyyAO-container", ref: dynamicRef(`${niP5RIolcamnlWJ0bR}-${layoutId}-1n6qscb`), children: /* @__PURE__ */ _jsx3(stdin_default4, { height: "100%", id: "UzGzlyyAO", layoutId: "UzGzlyyAO", variant: loaderVariants(paginationInfo, { disabled: "PX1MOnVXY", loading: "G47S15YSn" }, "G47S15YSn"), width: "100%" }) }) })] }) }) }) })], emptyState: [], favouritesOnly: false, favouriting: false, filtering: false, height: "100%", id: "vGLIJzFFe", itemsPerPage: 4, layoutId: "vGLIJzFFe", pagination: false, paginationType: "prevNextButtons", randomize: false, scrollUp: { filteringEnabled: false, offset: 0, paginationEnabled: true, scrollStyle: "smooth", sortingEnabled: false }, search: true, searchFields: [{ fieldName: "Title", fieldType: "default", referenceFieldName: "" }], slugFieldName: "Slug", sorting: false, style: { width: "100%" }, superfieldsId: 1, width: "100%" }) }) })] }) }) }) });
});
var css3 = ["@supports (aspect-ratio: 1) { body { --framer-aspect-ratio-supported: auto; } }", ".framer-leZ5S.framer-159au5i, .framer-leZ5S .framer-159au5i { display: block; }", ".framer-leZ5S.framer-x2v1em { align-content: center; align-items: center; display: flex; flex-direction: column; flex-wrap: nowrap; gap: 30px; height: 600px; justify-content: flex-start; padding: 100px; position: relative; width: 1072px; }", ".framer-leZ5S .framer-1xavbf3 { align-content: center; align-items: center; display: flex; flex: none; flex-direction: row; flex-wrap: nowrap; gap: 31px; height: min-content; justify-content: center; overflow: visible; padding: 0px; position: relative; width: 100%; }", ".framer-leZ5S .framer-bmisar-container, .framer-leZ5S .framer-1n6qscb-container { flex: none; height: auto; position: relative; width: auto; }", ".framer-leZ5S .framer-1ch9a9y-container { flex: 1 0 0px; height: auto; position: relative; width: 1px; }", ".framer-leZ5S .framer-hsh8lz-container { flex: none; height: auto; position: relative; width: 100%; }", ".framer-leZ5S .framer-1ut4cls { align-content: flex-start; align-items: flex-start; display: flex; flex-direction: column; flex-wrap: nowrap; gap: 20px; height: min-content; justify-content: center; padding: 0px; position: relative; width: min-content; }", ".framer-leZ5S .framer-m830a { align-content: center; align-items: center; display: flex; flex: none; flex-direction: row; flex-wrap: nowrap; gap: 10px; height: min-content; justify-content: flex-start; padding: 0px; position: relative; width: min-content; }", ".framer-leZ5S .framer-1qpnbi7 { flex: none; height: auto; position: relative; white-space: pre; width: auto; }", "@supports (background: -webkit-named-image(i)) and (not (font-palette:dark)) { .framer-leZ5S.framer-x2v1em, .framer-leZ5S .framer-1xavbf3, .framer-leZ5S .framer-1ut4cls, .framer-leZ5S .framer-m830a { gap: 0px; } .framer-leZ5S.framer-x2v1em > * { margin: 0px; margin-bottom: calc(30px / 2); margin-top: calc(30px / 2); } .framer-leZ5S.framer-x2v1em > :first-child, .framer-leZ5S .framer-1ut4cls > :first-child { margin-top: 0px; } .framer-leZ5S.framer-x2v1em > :last-child, .framer-leZ5S .framer-1ut4cls > :last-child { margin-bottom: 0px; } .framer-leZ5S .framer-1xavbf3 > * { margin: 0px; margin-left: calc(31px / 2); margin-right: calc(31px / 2); } .framer-leZ5S .framer-1xavbf3 > :first-child, .framer-leZ5S .framer-m830a > :first-child { margin-left: 0px; } .framer-leZ5S .framer-1xavbf3 > :last-child, .framer-leZ5S .framer-m830a > :last-child { margin-right: 0px; } .framer-leZ5S .framer-1ut4cls > * { margin: 0px; margin-bottom: calc(20px / 2); margin-top: calc(20px / 2); } .framer-leZ5S .framer-m830a > * { margin: 0px; margin-left: calc(10px / 2); margin-right: calc(10px / 2); } }", ...css];
var FrameruSJVhQSyB = withCSS3(Component2, css3, "framer-leZ5S");
var stdin_default5 = FrameruSJVhQSyB;
FrameruSJVhQSyB.displayName = "Famous Filter";
FrameruSJVhQSyB.defaultProps = { height: 600, width: 1072 };
addFonts2(FrameruSJVhQSyB, [{ explicitInter: true, fonts: [{ family: "Inter", source: "framer", style: "normal", unicodeRange: "U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F", url: "https://framerusercontent.com/assets/5vvr9Vy74if2I6bQbJvbw7SY1pQ.woff2", weight: "400" }, { family: "Inter", source: "framer", style: "normal", unicodeRange: "U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116", url: "https://framerusercontent.com/assets/EOr0mi4hNtlgWNn9if640EZzXCo.woff2", weight: "400" }, { family: "Inter", source: "framer", style: "normal", unicodeRange: "U+1F00-1FFF", url: "https://framerusercontent.com/assets/Y9k9QrlZAqio88Klkmbd8VoMQc.woff2", weight: "400" }, { family: "Inter", source: "framer", style: "normal", unicodeRange: "U+0370-03FF", url: "https://framerusercontent.com/assets/OYrD2tBIBPvoJXiIHnLoOXnY9M.woff2", weight: "400" }, { family: "Inter", source: "framer", style: "normal", unicodeRange: "U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF", url: "https://framerusercontent.com/assets/JeYwfuaPfZHQhEG8U5gtPDZ7WQ.woff2", weight: "400" }, { family: "Inter", source: "framer", style: "normal", unicodeRange: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD", url: "https://framerusercontent.com/assets/vQyevYAyHtARFwPqUzQGpnDs.woff2", weight: "400" }, { family: "Inter", source: "framer", style: "normal", unicodeRange: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB", url: "https://framerusercontent.com/assets/b6Y37FthZeALduNqHicBT6FutY.woff2", weight: "400" }] }, ...FilterFonts, ...SearchBarFonts, ...SpinnerFonts, ...SuperfieldsFonts, ...getFontsFromSharedStyle(fonts)], { supportsExplicitInterCodegen: true });

// virtual:famous-filter
import { WithFramerBreakpoints } from "unframer";
import { jsx } from "react/jsx-runtime";
var locales = [];
var defaultResponsiveVariants = {};
stdin_default5.Responsive = ({ locale, ...rest }) => {
  return /* @__PURE__ */ jsx(
    ContextProviders,
    {
      routes: { "augiA20Il": { "path": "/" } },
      children: /* @__PURE__ */ jsx(
        WithFramerBreakpoints,
        {
          Component: stdin_default5,
          variants: defaultResponsiveVariants,
          ...rest
        }
      ),
      framerSiteId: "3e9f5e2dfe1fa837fdde6786fd170fa8b16329662ea08209301f1736684b7d60",
      locale,
      locales
    }
  );
};
function ComponentWithRoot({ locale, ...rest }) {
  return /* @__PURE__ */ jsx(
    ContextProviders,
    {
      routes: {
        "augiA20Il": {
          "path": "/"
        }
      },
      children: /* @__PURE__ */ jsx(stdin_default5, { ...rest }),
      framerSiteId: "3e9f5e2dfe1fa837fdde6786fd170fa8b16329662ea08209301f1736684b7d60",
      locale,
      locales
    }
  );
}
Object.assign(ComponentWithRoot, stdin_default5);
export {
  ComponentWithRoot as default
};
